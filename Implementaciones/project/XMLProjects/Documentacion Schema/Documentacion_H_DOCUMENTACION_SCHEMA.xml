<?xml version="1.0"?>
<DTS:Executable xmlns:DTS="www.microsoft.com/SqlServer/Dts"
  DTS:refId="Package"
  DTS:CreationDate="2/5/2020 3:33:24 PM"
  DTS:CreationName="Microsoft.Package"
  DTS:CreatorComputerName="LA22671-08835"
  DTS:CreatorName="AMS\nborio"
  DTS:DTSID="{7A59C46D-EF87-4882-B5F9-C8CB2CA92ECA}"
  DTS:ExecutableType="Microsoft.Package"
  DTS:LastModifiedProductVersion="15.0.1301.433"
  DTS:LocaleID="11274"
  DTS:ObjectName="Documentacion_H_DOCUMENTACION_SCHEMA"
  DTS:PackageType="5"
  DTS:VersionBuild="6"
  DTS:VersionGUID="{DAABBDFE-76D3-46C2-9700-5B614DC74DCC}">
  <DTS:Property
    DTS:Name="PackageFormatVersion">8</DTS:Property>
  <DTS:LogProviders>
    <DTS:LogProvider
      DTS:ConfigString="DS_MSDB"
      DTS:CreationName="Microsoft.LogProviderSQLServer"
      DTS:Description="Writes log entries for events to a SQL Server database"
      DTS:DTSID="{7BC109EC-FB00-411C-BDD0-ACB33161957E}"
      DTS:ObjectName="SSIS log provider for SQL Server">
      <DTS:ObjectData>
        <InnerObject />
      </DTS:ObjectData>
    </DTS:LogProvider>
  </DTS:LogProviders>
  <DTS:Variables />
  <DTS:LoggingOptions
    DTS:FilterKind="0"
    DTS:LoggingMode="1">
    <DTS:SelectedLogProviders>
      <DTS:SelectedLogProvider
        DTS:InstanceID="{7BC109EC-FB00-411C-BDD0-ACB33161957E}" />
    </DTS:SelectedLogProviders>
  </DTS:LoggingOptions>
  <DTS:Executables>
    <DTS:Executable
      DTS:refId="Package\H_DOCUMENTACION_SCHEMA"
      DTS:CreationName="Microsoft.ExecuteSQLTask"
      DTS:Description="Tarea Ejecutar SQL"
      DTS:DTSID="{106b9728-8fe3-4797-b33e-b80062f7b25d}"
      DTS:ExecutableType="Microsoft.ExecuteSQLTask"
      DTS:LocaleID="-1"
      DTS:ObjectName="H_DOCUMENTACION_SCHEMA"
      DTS:ThreadHint="0">
      <DTS:Variables />
      <DTS:LoggingOptions
        DTS:FilterKind="0" />
      <DTS:ObjectData>
        <SQLTask:SqlTaskData
          SQLTask:Connection="{60170DD5-0B9F-4310-9EB3-380CE6FAF9F1}"
          SQLTask:SqlStatementSource="&#xA;-----------ARMADO DE MATRIZ DE DOCUMENTACIÓN------------------&#xA;  &#xA; TRUNCATE TABLE DW_Salud.dbo.H_DOCUMENTACION_SCHEMA&#xA; &#xA; --INSERTA METRICAS QUE SALEN UNICAMENTE DE 1 TABLA. &#xA;&#xA; INSERT INTO DW_Salud.dbo.H_DOCUMENTACION_SCHEMA&#xA; (id_tabla_schema, id_atributo_schema, id_metrica_schema, cantidad)&#xA; select distinct T.id_tabla_schema, A.id_atributo_schema, M.id_metrica_schema, 1 as Cantidad&#xA; from DW_Salud.dbo.D_DOCUMENTACION_TABLAS T&#xA; INNER JOIN DW_Salud.dbo.H_DOCUMENTACION_ATRIBUTOS A on A.id_tabla_schema = T.id_tabla_schema&#xA; INNER JOIN (select id_metrica_schema, max(id_tabla_schema) as id_tabla_schema from DW_Salud.dbo.H_DOCUMENTACION_METRICAS group by id_metrica_schema having count(distinct id_tabla_schema) = 1) M &#xA; on A.id_tabla_schema = M.id_tabla_schema&#xA; --where id_atributo_schema = '787FF61E-7E08-496E-AC13-36C273583073'&#xA; order by T.id_tabla_schema, A.id_atributo_schema, M.id_metrica_schema&#xA;&#xA;&#xA; --INSERTA METRICAS QUE SALEN DE 2 O MAS TABLAS. ejemplo: indice de egreso (bajas/stock), costo de salud ((consumo amb+consumo int)/ reca)&#xA;&#xA; DECLARE cursor_metricas cursor for (select id_metrica_schema from H_DOCUMENTACION_METRICAS group by id_metrica_schema having count(distinct id_tabla_schema) &gt; 1 and  count(distinct id_tabla_schema) &lt; 4)&#xA; declare @id_metrica varchar(200) = ''&#xA;&#xA; open cursor_metricas&#xA; FETCH NEXT FROM cursor_metricas into @id_metrica&#xA;&#xA; while @@FETCH_STATUS = 0&#xA; begin&#xA;  INSERT INTO DW_Salud.dbo.H_DOCUMENTACION_SCHEMA&#xA;  (id_tabla_schema, id_atributo_schema, id_metrica_schema, cantidad)&#xA;  select TAB.id_tabla_schema, ATT.id_atributo_schema, MET.id_metrica_schema, 1 as cantidad &#xA;  from  &#xA;  (select id_metrica_schema, count(distinct id_tabla_schema) as cant_tab &#xA;  from H_DOCUMENTACION_METRICAS &#xA;  where id_metrica_schema =  @id_metrica&#xA;  group by id_metrica_schema) MET join &#xA;  (select distinct id_atributo_schema, count(distinct id_tabla_schema) cant_tab&#xA;  from H_DOCUMENTACION_ATRIBUTOS &#xA;  where id_tabla_schema in (select distinct id_tabla_schema from H_DOCUMENTACION_METRICAS where id_metrica_schema =  @id_metrica)&#xA;  group by id_atributo_schema) ATT on MET.cant_tab = ATT.cant_tab&#xA;  cross join (select distinct id_tabla_schema  from H_DOCUMENTACION_METRICAS where id_metrica_schema =  @id_metrica) TAB&#xA;&#xA;  FETCH NEXT FROM cursor_metricas into @id_metrica&#xA; end&#xA; close cursor_metricas&#xA; deallocate cursor_metricas&#xA; &#xA;&#xA;---INSERTAMOS COMBINACIONES POSIBLES PARA LOS ATRIBUTOS Y SUS PADRES E HIJOS&#xA;&#xA;/* OBSERVACION 1: se deduce que toda metrica que pueda ser utilizada con un atributo, &#xA;tambien va a estar disponible para todos los padres de ese att en cascada, siempre y cuando la relacion este dada por una tabla de dimensión.&#xA;&#xA;--OBSERVACION 2: si la relacion esta dada en tablas de hechos, SOLAMENTE las metricas de ESA MISMA tabla de hechos van a estar disponibles&#xA;para todos los padres de ese att en cascada.&#xA;&#xA;OBSERVACION 3: estas tablas por la forma que tienen de modelarse de-normalizadas son excepciones a las regas de  arriba&#xA;*/&#xA;&#xA;create table #TablasExceptuadas (nombre_tabla varchar(50) collate SQL_Latin1_General_CP850_CI_AI) &#xA;insert into #TablasExceptuadas values ('H_CONVENIOS_EMPRESAS')&#xA;insert into #TablasExceptuadas values ('H_ASOCIADO_INTERES_COMERCIAL')&#xA;&#xA;&#xA;&#xA;--arranca el ciclo&#xA; --calcula cuantas filas inserta en una variable&#xA; --inserta las combinaciones que no existen en la tabla de metrica tabla atributo&#xA; --controla si al variable es nula y activa el fin de ciclo si no sigue.&#xA;&#xA;declare @FinCiclo int = 0&#xA;declare @CantFilas int = 0&#xA;&#xA;while @FinCiclo = 0&#xA;begin&#xA; set @CantFilas = (select count(*) from H_DOCUMENTACION_SCHEMA a11&#xA;  JOIN H_DOCUMENTACION_ATRIBUTOS_RELACIONES RA on RA.id_atributo_hijo = a11.id_atributo_schema and RA.id_tabla_atributo_hijo = a11.id_tabla_schema&#xA;  join D_DOCUMENTACION_METRICAS a12&#xA;    on  (a11.id_metrica_schema = a12.id_metrica_schema)&#xA; where a12.id_proyecto in (1,2)&#xA; and not exists (select 1 from H_DOCUMENTACION_SCHEMA H2 where H2.id_tabla_schema = a11.id_tabla_schema and H2.id_atributo_schema = RA.id_atributo_padre and H2.id_metrica_schema = a11.id_metrica_schema)&#xA; and RA.id_atributo_padre is not null&#xA; and RA.tabla_atributo_hijo like 'H_%' and RA.tabla_atributo_hijo not in (select nombre_tabla  from #TablasExceptuadas)) --esta es una excepcion a las reglas.&#xA;&#xA; set @CantFilas = @CantFilas + (select count(*) from H_DOCUMENTACION_SCHEMA a11&#xA;  JOIN H_DOCUMENTACION_ATRIBUTOS_RELACIONES RA on RA.id_atributo_hijo = a11.id_atributo_schema &#xA;  join D_DOCUMENTACION_METRICAS a12&#xA;    on  (a11.id_metrica_schema = a12.id_metrica_schema)&#xA; where a12.id_proyecto in (1,2)&#xA; and not exists (select 1 from H_DOCUMENTACION_SCHEMA H2 where H2.id_tabla_schema = a11.id_tabla_schema and H2.id_atributo_schema = RA.id_atributo_padre and H2.id_metrica_schema = a11.id_metrica_schema)&#xA; and RA.id_atributo_padre is not null&#xA; and (RA.tabla_atributo_hijo like 'D_%'or RA.tabla_atributo_hijo in (select nombre_tabla from #TablasExceptuadas)))--esta es una excepcion a la regla&#xA;&#xA; --las variables se suman, porque si ninguna de las 2 lecturas inserto datos tiene que finalizar, pero si una de las 2 inserta, tiene que seguir.&#xA;&#xA; insert into H_DOCUMENTACION_SCHEMA&#xA; (id_tabla_schema,id_atributo_schema,id_metrica_schema,cantidad)&#xA; select a11.id_tabla_schema,&#xA;     isnull(RA.id_atributo_padre,0),&#xA;     a11.id_metrica_schema  id_metrica_schema,&#xA;     1 as cantidad&#xA; from H_DOCUMENTACION_SCHEMA a11&#xA;  JOIN H_DOCUMENTACION_ATRIBUTOS_RELACIONES RA on RA.id_atributo_hijo = a11.id_atributo_schema and RA.id_tabla_atributo_hijo = a11.id_tabla_schema&#xA;  join D_DOCUMENTACION_METRICAS a12&#xA;    on  (a11.id_metrica_schema = a12.id_metrica_schema)&#xA; where a12.id_proyecto in (1,2)&#xA; and not exists (select 1 from H_DOCUMENTACION_SCHEMA H2 where H2.id_tabla_schema = a11.id_tabla_schema and H2.id_atributo_schema = RA.id_atributo_padre and H2.id_metrica_schema = a11.id_metrica_schema)&#xA; and RA.id_atributo_padre is not null&#xA; and RA.tabla_atributo_hijo like 'H_%' and RA.tabla_atributo_hijo not in (select nombre_tabla from #TablasExceptuadas) --esta es una excepcion a las reglas.&#xA; group by a11.id_metrica_schema,&#xA;  a11.id_tabla_schema,&#xA;  RA.id_atributo_padre&#xA;&#xA; UNION ALL&#xA;&#xA; select a11.id_tabla_schema,&#xA;     isnull(RA.id_atributo_padre,0),&#xA;     a11.id_metrica_schema  id_metrica_schema,&#xA;     1 as cantidad&#xA; from H_DOCUMENTACION_SCHEMA a11&#xA;  JOIN H_DOCUMENTACION_ATRIBUTOS_RELACIONES RA on RA.id_atributo_hijo = a11.id_atributo_schema &#xA;  join D_DOCUMENTACION_METRICAS a12&#xA;    on  (a11.id_metrica_schema = a12.id_metrica_schema)&#xA; where a12.id_proyecto in (1,2)&#xA; and not exists (select 1 from H_DOCUMENTACION_SCHEMA H2 where H2.id_tabla_schema = a11.id_tabla_schema and H2.id_atributo_schema = RA.id_atributo_padre and H2.id_metrica_schema = a11.id_metrica_schema)&#xA; and RA.id_atributo_padre is not null&#xA; and (RA.tabla_atributo_hijo like 'D_%'or RA.tabla_atributo_hijo in (select nombre_tabla from #TablasExceptuadas))--esta es una excepcion a la regla&#xA; group by a11.id_metrica_schema,&#xA;  a11.id_tabla_schema,&#xA;  RA.id_atributo_padre &#xA; &#xA; if @CantFilas = 0 --si no inserto ninguna fila es porque ya no queda mas nada que insertar, entonces finaliza el proceso&#xA;  set @FinCiclo = 1&#xA;end&#xA;&#xA;drop table #TablasExceptuadas" xmlns:SQLTask="www.microsoft.com/sqlserver/dts/tasks/sqltask" />
      </DTS:ObjectData>
    </DTS:Executable>
  </DTS:Executables>
  <DTS:DesignTimeProperties><![CDATA[<?xml version="1.0"?>
<!--This CDATA section contains the layout information of the package. The section includes information such as (x,y) coordinates, width, and height.-->
<!--If you manually edit this section and make a mistake, you can delete it. -->
<!--The package will still be able to load normally but the previous layout information will be lost and the designer will automatically re-arrange the elements on the design surface.-->
<Objects
  Version="8">
  <!--Each node below will contain properties that do not affect runtime behavior.-->
  <Package
    design-time-name="Package">
    <LayoutInfo>
      <GraphLayout
        Capacity="4" xmlns="clr-namespace:Microsoft.SqlServer.IntegrationServices.Designer.Model.Serialization;assembly=Microsoft.SqlServer.IntegrationServices.Graph">
        <NodeLayout
          Size="245,42"
          Id="Package\H_DOCUMENTACION_SCHEMA"
          TopLeft="250,105" />
      </GraphLayout>
    </LayoutInfo>
  </Package>
</Objects>]]></DTS:DesignTimeProperties>
</DTS:Executable>